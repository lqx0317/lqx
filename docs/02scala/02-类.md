# 1.类的定义与使用
## 1.1.创建类
scala中默认的访问控制为public，就是说，不显示声明访问修饰符时，默认为public。
### class关键字 类名标识符

```
scala> class User
defined class User

scala> val user1 = new User
user1: User = User@550a1967
```
scala编译器干了什么？查看编译器所生成的代码：
- 创建`User.scala`文件
- 键入
```
class User
```
- 使用`scalac User.scala`编译代码
- 运行`javap -private User`查看编译器所生成的代码
```
Compiled from "User.scala"
public class User {
  public User();
}
```
### class关键字 类名标识符 参数

```
scala> class Person(var name: String, var age: Int)
defined class Person

scala> val a1=new Person("Mike",30)
a1: Person = Person@4426bff1

scala> a1.name
res3: String = Mike

scala> a1.age
res4: Int = 30
```
当参数声明为`var`时，编译器干了什么？

scala文件`Person.scala`
```
class Person1(var name:String)
```
scala编译器生成的代码
```
Compiled from "Person1.scala"
public class Person1 {
  private java.lang.String name;
  public java.lang.String name();
  public void name_$eq(java.lang.String);
  public Person1(java.lang.String);
}
```
当参数声明为`val`时，编译器干了什么？

scala文件`Person2.scala`
```
class Person2(val name:String)
```
scala编译器生成的代码
```
Compiled from "Person2.scala"
public class Person2 {
  private final java.lang.String name;
  public java.lang.String name();
  public Person2(java.lang.String);
}
```
### class关键字 类名标识符 类主体
scala文件`Person3.scala`
```
class Person3 {
  var name:String = _  //scala要求变量在使用前必须初始化，下划线表示相应类型的默认值
}
```
scala编译器生成的代码
```
Compiled from "Person3.scala"
public class Person3 {
  private java.lang.String name;
  public java.lang.String name();
  public void name_$eq(java.lang.String);
  public Person3();
}
```
同`Person1.scala`相似，只是类中的构造器没有参数。

### class关键字 类名标识符 参数 类主体
scala文件`Person4.scala`
```
class Person4(var name:String) {
  var age:Int = _ 
}
```
scala编译器生成的代码
```
Compiled from "Person4.scala"
public class Person4 {
  private java.lang.String name;
  private int age;
  public java.lang.String name();
  public void name_$eq(java.lang.String);
  public int age();
  public void age_$eq(int);
  public Person4(java.lang.String);
}
```

## 1.2.实例
## 1.3.定义字段
### 字段定义在参数中
在scala中，类构造器的参数定义了字段，并自动生成了访问器方法。字段声明为不可变val时，自动生成了getter；字段声明为可变var时，自动生成了getter和setter。
scala文件`Person5.scala`
```
class Person5(val name:String,var age:Int)
```
scala编译器生成的代码
```
Compiled from "Person5.scala"
public class Person5 {
  private final java.lang.String name;
  private int age;
  public java.lang.String name();
  public int age();
  public void age_$eq(int);
  public Person5(java.lang.String, int);
}
```
- 不可变的name字段的访问控制private
```
private final java.lang.String name;
```
- 不可变的name字段静态类型
```
private final java.lang.String name;
```
- 不可变的name字段的getter
```
public java.lang.String name(); //getter
```
- 可变的age字段访问控制private
```
private int age;
```
- 可变的age字段非静态类型
```
private int age;
```
- 可变的age字段getter、setter
```
 public int age(); //getter
  public void age_$eq(int);  //setter
```
#### 字段的使用

```
scala> class Person5(val name:String,var age:Int)
defined class Person5

scala> val person=new Person5("mike",30)
person: Person5 = Person5@e2d56bf

scala> person.name
res0: String = mike

scala> person.age
res1: Int = 30

scala> person.age = 31
person.age: Int = 31

scala> person.age
res2: Int = 31

scala> person.name = "mik"
<console>:13: error: reassignment to val
       person.name = "mik"
                   ^
```
- 不可变字段name访问
`person.name`
- 可变字段age访问
`person.age`
- 可变字段age变更
`person.age = 31`

#### 使用字段的内在机制
字段定义在类参数中，访问权限为private，那么为什么还能在类外使用字段呢。表面上看是直接操作的字段，实际上是在调用getter和setter方法。在这里，age字段的getter和setter分别叫做 age 和 age_=（JVM不允许方法名出现=，所以是age_$eq）。

#### 自定义setter和getter
```
scala> class Person{private var myAge=0 ;def age = myAge;def age_=(value:Int){if(value>myAge) myAge=value}}
defined class Person
scala> val person=new Person
person: Person = Person@69a3d1d

scala> person.age=30
person.age: Int = 30

scala> person.age
res3: Int = 30

scala> person.age=20
person.age: Int = 30

scala> person.age
res4: Int = 30

```
可以看出，`person.age`将调用方法`person.age()`，`person.age=30`将调用方法`person_=(30)`方法传参为30。
#### 编译器为什么自动生成setter和getter

>颇具影响的Eiffel语言的发明者Bertrand Meyer提出了统一访问原则，内容如下：”某个模块提供的所有服务都应该能通过统一的表示法访问到，至于它们是通过存储还是通过计算来实现的，从访问方式上应无从获知。“在scala中，person.age的调用者并不知道age是通过字段还是通过方法来实现的。（当然了，在JVM中，该服务总是通过方法来实现的，要么是编译器合成，要么由程序员提供。）

### 字段定义在类主体中
## 1.4.定义方法
## 1.5.定义构造器

## 1.6.表达式或可执行语句
在实例化类的时候，scala会执行主构造器中任意表达式和直接内置在类定义中的可执行语句。
### 函数表达式
#### toString 方法
```
scala> class User
defined class User

scala> val user=new User
user: User = User@59fa1d9b
```
实例化的时候输出类名和一个十六进制串`User@59fa1d9b`，十六进制串是内存位置。为什么会输出这个呢，这个结果是由JVM的java.lang.Object.toString方法输出的，java.lang.Object是JVM中所有实例的根。所以scala会从根继承toString方法，打印实例时，就会调用toString方法。

toString方法重载：
```
scala> class User{override def toString = "Hello World!"}
defined class User

scala> val user = new User
user: User = Hello World!
```
一般情况下，会将toString方法重载为更有信息含量。

### 可执行语句
类主体中定义了print可执行语句，在实例化的时候会执行。
```
scala> class User{println("hello world!")}
defined class User

scala> val user = new User
hello world!
user: User = User@2096442d
```