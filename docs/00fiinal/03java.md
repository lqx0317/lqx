# 术语及解释

不分先后顺序。
## 0.基本概念
- 

## 1.接口 Interface
##### 定义
>在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以Interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
```
//接口的声明
[可见度] interface 接口名称 [extends 其他的接口名]{
    [public static final] String str = "hello";//声明变量
    [public abstract] void eat();//抽象方法
//接口的实现
}
public class 类名 implements 接口名称[...,其他接口名称，...]{
    public void eat(){
        //
    }
}
```
##### 特点
- 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
- 接口中的方法都是公有public的，隐式抽象的，声明时不必显式使用public、abstract关键字。声明方法时不写public不代表是default，默认就是public。约定声明方法要写public，为了避免混淆，但是可以不写abstract。
- 接口中的成员变量都是public、static、final的，不必显式使用这些关键字声明。
- 在接口中，所有的方法必须都是抽象的，默认为public abstract，在声明方法时可以省略这些关键字，不能有方法体，它比抽象类更加抽象。
- 使用关键字`interface`来声明，接口可以指定一个类必须做什么，而不是规定如何去做。
- 现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。
- 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法，并添加新的抽象方法。
- 接口没有构造方法，不能被实例化。
- 类只能单继承，多实现；接口可以多继承。`public interface C extends A,B`
- 接口在继承链中可插入，解决了Java程序的单继承问题。
- Java项目在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。
- 接口必须通天类来实现（implements）它的抽象方法，然后再实例化类。
- 接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，`interface A{};class B implements A{};A a = new B();`，接口的对象利用子类对象的向上转型进行实例化操作
- 接口的使用率是最高的，所有的设计基本是围绕接口进行的，与接口相关的两个重要设计模式：工厂设计模式、代理设计模式。
- 接口一定要定义子类，子类必须覆写接口中的全部抽象方法
- 抽象类可以实现接口
- 大多数情况下接口中不会定义全局常量
- 实际开发中接口的三个使用原则：指定操作的标准；表示一种能力；将服务器端的远程方法视图提供给客户端。

##### 举例

## 2.泛化
##### 定义
>泛化（generalize）是将一些不必要的特殊值（比如常量）用更普遍化的值代替（比如变量或参数）的过程。泛化可以增加程序的可重用性，有时还可以使程序更易阅读。
##### 特点
##### 举例

## 3.泛型
##### 定义
##### 特点
- 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
- 泛型的本质是参数化类型，参数就是定义方法的时候定义形参（局部变量），调用方法（执行方法）的时候传递实参（引用，或变量值）。参数化类型就是将原来具体的类型参数化
- 泛型是一种语法糖，在编译阶段完成类型转化，避免在运行时候强制类型转换出现的错误。
- java中泛型是JDK1.5的新特性，在1.5及之后版本中支持
- Java的泛型就是在定义的同时明确指明其类型，增强程序的可读性，同时类型的检查在编译阶段就可以完成，避免运行时的异常，从而使程序有更强的健壮性。例如：传统的定义容器对象：`Map m = new HashMap()`，使用泛型定义对象：`Map<Integer, News> = new HashMap<Integer, News>()`

##### 举例

## 4.泛型方法
##### 定义
##### 特点
- 定义一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。

##### 举例

## 5.Java容器（集合）
##### 定义
##### 特点
- java容器设计目标：该框架必须是高性能的，基本集合的实现也是高效的。该框架允许不同类型的集合。对一个集合的扩展和适应必须是简单的。
- ArrayList:元素可重复且有序、修改和查找效率高、频繁访问列表元素和在列表末尾添加删除元素的场景用ArrayList
- LinkedList:增加和删除效率高、频繁在列表任意位置进行增加删除元素用LinkList、通过循环迭代来访问列表中的元素用LinkList
- HashSet:元素不重复且无序、
- HashMap:键值对

### 5.1.ArrayList
##### 定义
```
import java.util.ArrayList; //引入 ArrayList 类
ArrayList<E> a = new ArrayList<>(); //初始化
ArrayList<String> sites = new ArrayList<String>();
sites.add("baidu");
sites.add("google");
ArrayList<Integer> n = new Array<Integer>();
n.add(1);
```
##### 特点
- ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。
- ArrayList继承了AbstractList，并实现了List接口
- ArrayList类位于 `java.util` 包中
- ArrayList是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。常用方法有`增add()、删remove()、改set()、查get()、排序sort()、size()`
- 可以用`for`和`for-each`迭代元素。
- ArrayList中的元素都是引用数据类型的对象，如果要存储基本类型，需要用到基本类型的包装类。

##### 举例

### 5.2.LinkList
##### 定义
```
import java.util.LinkedList
LinkedList<String> sites = new LinkedList<String>();
sites.add("baidu");
sites.add("google");
System.out.println(sites); //打印列表元素
sites.addFirst("weibo"); //在表头添加元素
sites.addLast("wangyi"); //在表尾添加元素
sites.removeFirst();
sites.removeLast();
sites.getFirst();
sites.getLast();
```
##### 特点
- LinkedList继承了AbstractSequentialList类；实现了Queue接口，可作为队列使用；实现了List接口，可进行列表操作；实现了java.io.Serializable接口，可支持序列化，能通过序列化去传输。
- 常用方法：

##### 举例
### 5.3.HashSet
##### 定义
##### 特点
- HashSet基于HashMap来实现，是一个不允许有重复元素的集合，允许有null值，无序、不会记录插入的顺序，不是线程安全
- 实现了Set接口

##### 举例

### 5.4.HashMap
##### 定义
##### 特点
- HashMap是一个散列表，存储键值对。
- 实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。
- HashMap是无序的，不会记录插入的顺序
- HashMap继承了AbstractMap，实现了Map、Cloneable、java.io.Serializable接口


##### 举例

## 6.泛型与容器
##### 定义
##### 特点
- 在java编程中，常常用到在容器中存放对象或从容器中取出对象，并根据实际情况转型为相应的对象，但在转型过程中极易出现错误，且很难发现。而使用泛型则可以在存取对象时**明确指明对象的类型**，将问题暴露在编译阶段，由编译器检测，从而避免java在运行时出现转型异常，增加程序的可读性与稳定性，提高程序的运行效率。

##### 举例

## 7.异常
##### 定义
##### 特点
- 异常是程序运行是出现的非正常情况，如包含不合法的输入数据、数据越界存取、试图使用空引用。当错误发生时，希望程序能够只能化处理，而非导致系统崩溃。在不支持异常处理的编程语言中，错误只能手工检查和处理。Java的异常处理机制用面向对象的方法规范化管理运行时错误。
- 异常处理思想的由来：在面向过程的编程语言中，错误处理由程序员完成，造成程序员负担过重，且出错处理不规范。Java中的异常处理机制为方法的异常中止和错误处理提供清晰的接口：方法引发异常之后，可将异常抛出，由该方法的直接或间接调用者处理这个异常。
- Java处理异常的机制基于三种操作：声明异常、抛出异常、捕获异常。声明异常告诉编译器哪里可能出错，错误语句所在的方法会创建一个异常对象并将它传递给系统。异常对象包含有关异常信息，包括异常类型、出错时程序状态。方法抛出异常后，Java运行系统从当前方法开始，通过方法调用链向后搜索用来处理错误的代码。处理错误的代码（即处理器）应与抛出的异常类型相匹配，若未发现异常处理器，程序会中止。非程序捕获的异常用系统默认处理程序处理，显示描述异常的字符串，并打印异常发生处的堆栈轨迹并中止程序。
- Java异常体系结构：java把异常当做对象来处理，Throwable类是所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。Exception类分运行时异常（RuntimeException，也叫不检查异常Unchecked Exception）和非运行时异常（也叫检查异常Checked Exception）。Error是程序无法处理的错误（如OutOfMemoryError），这些异常发生时，JVM一般会选择线程中止。Exception是程序本身可以处理的异常，这种异常分为运行时异常和非运行时异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。非运行时异常是RuntimeException以外的异常，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过，如IOException、SQLException等以及用户自定义的Exception异常，一般情况不自定义检查异常。
- Java程序能够捕获异常，通常不会捕获错误。错误不在Java程序处理的范畴之内。
- try代码块出现异常，try块中后续代码会被跳过。如果捕获了产生的异常对象，执行完catch代码块后，执行catch后的内容。程序正常结束。
- 程序如果产生异常，自己能解决就解决。如果解决不了，谁调用就让谁去解决，如果调用者解决不了，最后交给JVM来解决。
- Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。Error用来表示JVM无法处理的错误，Exception分为两种：受检异常和非受检异常。受检异常需要用try...catch...语句捕获并进行处理，并且可以从异常中恢复。非受检异常是程序运行时的错误，例如空指针异常。
- Java使用了一种被称为“异常处理”的错误捕获机制来处理程序中的异常和错误。当JVM在执行应用程序的某种方法时遇到了非正常现象，比如数组下标越界、空指针应用等，JVM就会生成一个异常对象，把它抛给客户，以便向客户通报程序在运行中出现了问题。这里的客户可以是上层调用的方法，或者是终端用户。


##### 举例
### 7.1.抛出异常
### 7.2.捕获异常

# 一、Java基础
## 标识符
>标识符是用来标识类名、对象名、变量名、方法名、类型名、数组名、文件名的有效字符序列，也就是它们的名称。由字母、数字、下划线、$组成。首字母不能是数字。

命名规则：
- 类名，首字母大写
- 方法名，首字母小写
- 常量，全部字母大写
- 包名，所有字母小写

## 关键字
- 用于包、类、接口定义：package、class、interface
- 访问控制修饰符：public、private、protected、default
- 数据类型：byte、char、int、double、boolean
- 流程控制：if、else、while、switch、case、do、break、continue
- 异常处理：try、catch、finally、throw、throws
- 引用：this、supe
- 创建对象：new

## 保留字
true、false、null

## 常量
>常量是指在程序执行期间值不变的数据。
## 变量

## 基本数据类型
java怎么在内存中存储float和double值？
对于float值，在内存中占用4个字节共32bit，1 bit用来存符号，8 bit用来存指数，23 bit用来存尾数（有效部分）。
1.浮点数转换为二进制数。
对于4.25,4是整数部分，0.25是小数部分。整数部分4转换为二进制是100，
