# 一、Java
## （一）Java语言
### 1.java语言风格
#### （1）标识符
>标识符是用来标识类名、对象名、变量名、方法名、类型名、数组名、文件名的有效字符序列，也就是它们的名称。由字母、数字、下划线、\$组成。首字母不能是数字。

命名规则：
- 类名，首字母大写
- 方法名，首字母小写
- 常量，全部字母大写
- 包名，所有字母小写

#### （2）关键字
- 用于包、类、接口定义：package、class、interface
- 访问控制修饰符：public、private、protected、default
- 数据类型：byte、char、int、double、boolean
- 流程控制：if、else、while、switch、case、do、break、continue
- 异常处理：try、catch、finally、throw、throws
- 引用：this、supe
- 创建对象：new

#### （3）保留字
true、false、null

#### （4）常量
>常量是指在程序执行期间值不变的数据。
#### （5）变量

#### （6）泛化
##### 定义
>泛化（generalize）是将一些不必要的特殊值（比如常量）用更普遍化的值代替（比如变量或参数）的过程。泛化可以增加程序的可重用性，有时还可以使程序更易阅读。
##### 特点
##### 举例

#### （7）泛型
##### 定义
##### 特点
- 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。
- 泛型的本质是参数化类型，参数就是定义方法的时候定义形参（局部变量），调用方法（执行方法）的时候传递实参（引用，或变量值）。参数化类型就是将原来具体的类型参数化
- 泛型是一种语法糖，在编译阶段完成类型转化，避免在运行时候强制类型转换出现的错误。
- java中泛型是JDK1.5的新特性，在1.5及之后版本中支持
- Java的泛型就是在定义的同时明确指明其类型，增强程序的可读性，同时类型的检查在编译阶段就可以完成，避免运行时的异常，从而使程序有更强的健壮性。例如：传统的定义容器对象：`Map m = new HashMap()`，使用泛型定义对象：`Map<Integer, News> = new HashMap<Integer, News>()`

##### 举例

#### （8）泛型方法

#### （9）this.
this是一个特殊的关键字，表示当前创建的对象。

#### （10）this()
子类构造器，this()可以带形参也可以不带。构造器间相互调用。用于初始化子类本身的属性。

#### （11）super.
#### （12）super()
父类构造器，子类调用父类构造器用于初始化从父类继承来的属性。



##### 定义
##### 特点
- 定义一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。

##### 举例

### 2.基础数据类型
- java怎么在内存中存储float和double值？对于float值，在内存中占用4个字节共32bit，1 bit用来存符号，8 bit用来存指数，23 bit用来存尾数（有效部分）。

### 3.面向对象
#### ➤➤➤ 类 ➤➤➤
java对象属于完全面向对象的编程语言，代码设计的核心是类的设计，类的设计具有封装的特性，在类中封装了属性的描述和方法的描述。

#### （1）类
相关方法的集合，对象类型的一个模板。

#### （2）实例/对象
实例（instance），某种类型的一个对象。java中每个对象都是某种类型的实例。类的一个成员，每一个对象都是某个类的一个实例。

#### ➤➤➤ 构造器 ➤➤➤
#### （1）构造函数
构造器，构造函数，构造方法，用于初始化新建对象的实例变量的特殊方法。
- java中的构造方法是一种特殊类型的方法，用于初始化对象。java构造函数在对象创建时被调用。
- 调用构造函数时，将在内存中为对象分配内存。
- 构造函数返回当前类的实例（定义构造函数不能指定返回值类型，但它是有返回值的）
- 构造函数可以执行其他任务而不是初始化。比如：对象创建、启动线程、调用方法等。可以像在方法中执行的任何操作一样，在构造函数中也可以做到。
- 构造方法的灵活运用可以使程序运行起来既顺利可读性又强。

##### 构造函数定义规则
- 构造函数名称必须与类名称一致
- 构造函数不能指定返回类型

##### 构造函数约束规则
- 构造函数不属于成员函数，不能被继承。

#### （2）无参构造函数
没有参数的构造函数称为默认构造函数（default constructor）。
##### 语法
```
<class_name>(){}
```

- 因为构造函数无法被继承。如果类中没有定义构造函数，编译器会自动创建一个默认的构造函数。
- 默认构造函数的作用：默认构造函数根据类型为对象成员属性提供默认值，如：0、null等。

##### 例子
```java
public class Test {
    int id;
    String name;

    void display(){
        System.out.println(id+" "+name);
    }

    public static void main(String[] args) {
        Test test1 = new Test();
        test1.display();
    }
}
out:0 null
```

#### （3）参数化构造函数
具有参数的构造函数称为参数化构造函数。参数化构造函数用于为不同对象提供不同初始化的值。
- 当一个类声明了有参数的构造方法，编译器不会再创建一个无参构造方法。

#### （4）构造函数重载
构造函数重载是java中的一种技术，一个类可以有任何数量的「参数列表不同」的构造函数（构造方法名是类名）。编译器通过构造函数参数列表中的参数数量及其类型来区分这些构造函数。
- 参数列表参数数量不同
- 参数列表参数类型不同

构造方法的重载就是在同一个类中定义多个不同参数的构造方法，以适用于创建含有不同参数的对象时适用。这些构造方法或形参类型，或形参个数不同。当一个类中存在多个参数不同的构造方法，由类创建对象时，系统会自动根据对象实参的数目、类型和顺序来确定调用哪一个构造方法来完成对新对象的初始化工作。

同一个类中多个重载的构造方法也可以相互调用。当类中的一个构造方法需要调用另一个构造方法时，可以使用this()关键字，this()关键字根据需要可以带参数，也可以不带参数。

#### （5）初始化本类成员属性

#### （6）初始化继承来的成员属性
实例化一个对象时，编译器会调用相应的构造方法对成员属性进行初始化。

对于从父类继承而来的成员属性如何进行初始化？

在子类的构造方法中隐含调用了父类的无参构造方法super()，如果父类中不含无参构造方法，则需要在子类的构造方法中显式调用父类的构造方法，可以通过super(实参表)来进行调用。

#### （7）this()
同一个类中多个重载的构造方法也可以相互调用。当类中的一个构造方法需要调用另一个构造方法时，可以使用this()关键字，this()关键字根据需要可以带参数，也可以不带参数。
```java
public class Test {
    int id;
    String name;

    public Test(int a,String b){
        this.id = a;
        this.name = b;
    }
    public Test(int a){
        this(a,"zhangsan");
    }
    void display(){
        System.out.println(id+" "+name);
    }

    public static void main(String[] args) {
        Test test1 = new Test(01,"xavi");
        test1.display();
        Test test2 = new Test(99);
        test2.display();
    }
}
out:
1 xavi
99 zhangsan
```

#### （8）spuer()
super()用于调用直接父类构造函数。

#### （9）子类调用父类构造方法
在子类与父类的继承关系中，子类不能继承父类的构造方法，子类需要设计自己的构造方法生成对象，但可以调用父类的构造方法。在子类定义的构造方法中，可以使用this来调用本类的其他成员属性或方法，或者使用super来调用父类的构造方法。

#### ➤➤➤ Java对象 ➤➤➤
#### （1）对象的创建方式
java创建对象有5种方式。
- new关键字
- Class.newInstance
- Constructor.newInstance
- Clone方法
- 反序列化

https://cloud.tencent.com/developer/article/1497720
#### （2）new方法创建对象
调用构造函数。
#### （3）

#### 依赖注入、反射？

#### （1）new()
java对象的一般生产方法是用new()来创建的，在创建类的实例时，要做些初始化的工作，比如赋值、查询数据库等。这好比工厂中的产品在真正出厂交付客户之前，要做一些出厂设置或配置之类的工作。

new()方法存在的问题：
- 初始化工作较多
- 编码时不能预见需要创建哪一个类的实例。如果一个系统中存在较多的类，而且在编码时不能预见需要创建哪一个类的实例（实现相同接口的多个类），即需要根据一定的条件，来进行选择性的创建对象，用new()方法实现起来比较困难。
- 实例的创建信息需要隐藏，开发人员不希望创建了哪个类的实例以及如何创建实例的信息暴露给外部程序。

#### （2）工厂模式
由于以上问题，需要将创建实例的工作与使用实例的工作分开，也就是说，使创建实例所需要的大量初始化工作从类的构造函数中分离出去，因此我们提出了工厂模式。

#### ➤➤➤ 继承 ➤➤➤
#### （1）继承
java中继承是一种机制，表示为一个对象获取父对象的所有属性和方法。
- 继承表示为 is-a 关系，也称为父子关系。
- extends关键字表示从父类派生创建子类。”extends“的含义是增加功能。
- 通过继承一个类或的另一个类的属性或方法，达到扩充旧的程序以适应新的需求。

##### 继承的语法
```
class Subclass_name extends Superclass_name
{
    //methods and fields
}
```

#### （2）可继承成员
- 超类和子类在同一个包中
    - 😡超类中`private`关键字修饰的成员不能被子类继承
    - 😁超类中没有修饰符、`protected`、`public`修饰的成员都能被子类继承
- 超类和子类不在同一个包中
    - 😡超类中`private`、无修饰的成员不能被子类继承
    - 😁超类中`protected`、`public`修饰的成员都能被子类所继承

#### （3）重写（覆盖）
有时子类并不想原封不动地继承父类的方法，而是想作一定的修改，这就需要采用方法的重写（覆盖）。
- 继承过来的数据可以重写
- 继承过来的方法可以重写，当子类的成员方法与父类同名（参数列表也一样），子类会隐藏父类的成员，发生重写。

#### （4）重写变量
如果子类中定义了与父类同名的变量，父类的这个变量被隐藏。在子类中访问变量时，子类变量起作用，如果在子类中想引用父类被隐藏的变量，可以使用`super`访问父类被隐藏的变量或方法。
#### （5）重写方法

#### （6）子类对象和父类对象的转化
```
class Superclass{
    //
}
class Subclass{
    //
}
Superclass superclass = new Subclass(); //is-a
```
可以将子类对象赋值给父类对象，赋值后是什么情景？将子类对象赋值给父类对象，所得到的对象是这样一个对象，它是个编译为父类对象，但运行时时个子类对象。具体特征如下：
- 被声明为父类对象
- 拥有父类属性
- 占用子类的内存空间
- 子类方法覆盖父类的方法时，此时对象调用的是子类的方法。否则，自动调用继承父类的方法


#### ➤➤➤ 接口 ➤➤➤
#### （1）接口Interface
##### 定义
>在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以Interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
```
//接口的声明
[可见度] interface 接口名称 [extends 其他的接口名]{
    [public static final] String str = "hello";//声明变量
    [public abstract] void eat();//抽象方法
//接口的实现
}
public class 类名 implements 接口名称[...,其他接口名称，...]{
    public void eat(){
        //
    }
}
```
##### 特点
- 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
- 接口中的方法都是公有public的，隐式抽象的，声明时不必显式使用public、abstract关键字。声明方法时不写public不代表是default，默认就是public。约定声明方法要写public，为了避免混淆，但是可以不写abstract。
- 接口中的成员变量都是public、static、final的，不必显式使用这些关键字声明。
- 在接口中，所有的方法必须都是抽象的，默认为public abstract，在声明方法时可以省略这些关键字，不能有方法体，它比抽象类更加抽象。
- 使用关键字`interface`来声明，接口可以指定一个类必须做什么，而不是规定如何去做。
- 现实中也有很多接口的实例，比如说串口电脑硬盘，Serial ATA委员会指定了Serial ATA 2.0规范，这种规范就是接口。Serial ATA委员会不负责生产硬盘，只是指定通用的规范。
- 接口之间也可以继承，子接口可以继承父接口中的常量和抽象方法，并添加新的抽象方法。
- 接口没有构造方法，不能被实例化。
- 类只能单继承，多实现；接口可以多继承。`public interface C extends A,B`
- 接口在继承链中可插入，解决了Java程序的单继承问题。
- Java项目在设计阶段最重要的任务之一就是设计出各部分的接口，然后通过接口的组合，形成程序的基本框架结构。
- 接口必须通天类来实现（implements）它的抽象方法，然后再实例化类。
- 接口作为引用类型来使用，任何实现该接口的类的实例都可以存储在该接口类型的变量中，`interface A{};class B implements A{};A a = new B();`，接口的对象利用子类对象的向上转型进行实例化操作
- 接口的使用率是最高的，所有的设计基本是围绕接口进行的，与接口相关的两个重要设计模式：工厂设计模式、代理设计模式。
- 接口一定要定义子类，子类必须覆写接口中的全部抽象方法
- 抽象类可以实现接口
- 大多数情况下接口中不会定义全局常量
- 实际开发中接口的三个使用原则：指定操作的标准；表示一种能力；将服务器端的远程方法视图提供给客户端。

##### 举例


### 4.容器（集合）
#### （1）Java容器（集合）
##### 定义
##### 特点
- java容器设计目标：该框架必须是高性能的，基本集合的实现也是高效的。该框架允许不同类型的集合。对一个集合的扩展和适应必须是简单的。
- ArrayList:元素可重复且有序、修改和查找效率高、频繁访问列表元素和在列表末尾添加删除元素的场景用ArrayList
- LinkedList:增加和删除效率高、频繁在列表任意位置进行增加删除元素用LinkList、通过循环迭代来访问列表中的元素用LinkList
- HashSet:元素不重复且无序、
- HashMap:键值对

#### （1）ArrayList
##### 定义
```
import java.util.ArrayList; //引入 ArrayList 类
ArrayList<E> a = new ArrayList<>(); //初始化
ArrayList<String> sites = new ArrayList<String>();
sites.add("baidu");
sites.add("google");
ArrayList<Integer> n = new Array<Integer>();
n.add(1);
```
##### 特点
- ArrayList类是一个可以动态修改的数组，与普通数组的区别就是它是没有固定大小的限制，可以添加或删除元素。
- ArrayList继承了AbstractList，并实现了List接口
- ArrayList类位于 `java.util` 包中
- ArrayList是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。常用方法有`增add()、删remove()、改set()、查get()、排序sort()、size()`
- 可以用`for`和`for-each`迭代元素。
- ArrayList中的元素都是引用数据类型的对象，如果要存储基本类型，需要用到基本类型的包装类。

##### 举例

#### （2）LinkList
##### 定义
```
import java.util.LinkedList
LinkedList<String> sites = new LinkedList<String>();
sites.add("baidu");
sites.add("google");
System.out.println(sites); //打印列表元素
sites.addFirst("weibo"); //在表头添加元素
sites.addLast("wangyi"); //在表尾添加元素
sites.removeFirst();
sites.removeLast();
sites.getFirst();
sites.getLast();
```
##### 特点
- LinkedList继承了AbstractSequentialList类；实现了Queue接口，可作为队列使用；实现了List接口，可进行列表操作；实现了java.io.Serializable接口，可支持序列化，能通过序列化去传输。
- 常用方法：

##### 举例
#### （3）HashSet
##### 定义
##### 特点
- HashSet基于HashMap来实现，是一个不允许有重复元素的集合，允许有null值，无序、不会记录插入的顺序，不是线程安全
- 实现了Set接口

##### 举例

#### （4）HashMap
##### 定义
##### 特点
- HashMap是一个散列表，存储键值对。
- 实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。
- HashMap是无序的，不会记录插入的顺序
- HashMap继承了AbstractMap，实现了Map、Cloneable、java.io.Serializable接口

##### 举例

#### （5）泛型与容器
##### 定义
##### 特点
- 在java编程中，常常用到在容器中存放对象或从容器中取出对象，并根据实际情况转型为相应的对象，但在转型过程中极易出现错误，且很难发现。而使用泛型则可以在存取对象时**明确指明对象的类型**，将问题暴露在编译阶段，由编译器检测，从而避免java在运行时出现转型异常，增加程序的可读性与稳定性，提高程序的运行效率。

##### 举例

### 5.异常
##### 定义
##### 特点
- 异常是程序运行是出现的非正常情况，如包含不合法的输入数据、数据越界存取、试图使用空引用。当错误发生时，希望程序能够只能化处理，而非导致系统崩溃。在不支持异常处理的编程语言中，错误只能手工检查和处理。Java的异常处理机制用面向对象的方法规范化管理运行时错误。
- 异常处理思想的由来：在面向过程的编程语言中，错误处理由程序员完成，造成程序员负担过重，且出错处理不规范。Java中的异常处理机制为方法的异常中止和错误处理提供清晰的接口：方法引发异常之后，可将异常抛出，由该方法的直接或间接调用者处理这个异常。
- Java处理异常的机制基于三种操作：声明异常、抛出异常、捕获异常。声明异常告诉编译器哪里可能出错，错误语句所在的方法会创建一个异常对象并将它传递给系统。异常对象包含有关异常信息，包括异常类型、出错时程序状态。方法抛出异常后，Java运行系统从当前方法开始，通过方法调用链向后搜索用来处理错误的代码。处理错误的代码（即处理器）应与抛出的异常类型相匹配，若未发现异常处理器，程序会中止。非程序捕获的异常用系统默认处理程序处理，显示描述异常的字符串，并打印异常发生处的堆栈轨迹并中止程序。
- Java异常体系结构：java把异常当做对象来处理，Throwable类是所有异常和错误的超类，有两个子类Error和Exception，分别表示错误和异常。Exception类分运行时异常（RuntimeException，也叫不检查异常Unchecked Exception）和非运行时异常（也叫检查异常Checked Exception）。Error是程序无法处理的错误（如OutOfMemoryError），这些异常发生时，JVM一般会选择线程中止。Exception是程序本身可以处理的异常，这种异常分为运行时异常和非运行时异常。运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。非运行时异常是RuntimeException以外的异常，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过，如IOException、SQLException等以及用户自定义的Exception异常，一般情况不自定义检查异常。
- Java程序能够捕获异常，通常不会捕获错误。错误不在Java程序处理的范畴之内。
- try代码块出现异常，try块中后续代码会被跳过。如果捕获了产生的异常对象，执行完catch代码块后，执行catch后的内容。程序正常结束。
- 程序如果产生异常，自己能解决就解决。如果解决不了，谁调用就让谁去解决，如果调用者解决不了，最后交给JVM来解决。
- Throwable可以用来表示任何可以作为异常抛出的类，分为两种：Error和Exception。Error用来表示JVM无法处理的错误，Exception分为两种：受检异常和非受检异常。受检异常需要用try...catch...语句捕获并进行处理，并且可以从异常中恢复。非受检异常是程序运行时的错误，例如空指针异常。
- Java使用了一种被称为“异常处理”的错误捕获机制来处理程序中的异常和错误。当JVM在执行应用程序的某种方法时遇到了非正常现象，比如数组下标越界、空指针应用等，JVM就会生成一个异常对象，把它抛给客户，以便向客户通报程序在运行中出现了问题。这里的客户可以是上层调用的方法，或者是终端用户。


##### 举例
### （1）抛出异常
### （2）捕获异常

### 6.java哲学
- 面向对象=对象+类+继承+通信
- 面向对象的基本特征有四种：标识唯一性、分类性、多态性、继承性
- 面向对象软件开发技术：封装、继承、多态
#### （1）封装
#### （2）继承
#### （3）多态
多态性是一种方法，在多个类中可以定义一个操作和属性名，并在每一个类中有不同的实现。正式的说法就是同一个消息被不同的对象接收时，可产生不同的动作或执行结果，即每个对象将根据自己所属类中定义的操作执行。多态性就是相同的命令使得不同的类做出不同的响应。这些不同的类继承自同一个类，并对其父类方法做了不同的重写，导致不同的类有不同的表现行为。

## （二）数据结构
## （三）算法

### 1.算法分析
算法分析可评估算法的优劣。评价一个算法优劣的标准有三个：耗费时间长短；占用空间多少；是否易于理解、编码、调试、推广。

#### （1）无穷大渐近与阶
假如解决一个规模为 n 的问题所花费的时间表示为：$T(n) = 4n^2-2n+2$.

当 n 增大时，$n^2$ 项将开始占主导地位，而其他各项可以忽略，省略其他项对表达式的值的的影响将是可以忽略不计的。

进一步看，如果 n 一直增大，$n^2$ 项的系数也是无关紧要的。这样，$T(n)=O(f(n))=O(n^2)$

我们说该算法具有$n^2$阶的时间复杂度。   

#### （2）渐进表示
从数学上讲，可以把 f(n)=O(g(n)) 看作是关于极限，渐近的意思和微积分中渐近是一样的，我们在推理极限中某个量的行为。

#### （3）问题规模n
n 是问题的规模大小或者理解为算法所处理的数据总量。

#### （4）原操作
按照结构化程序设计的观点，程序和算法的基本结构只有三种，即顺序、选择和循环。
- 顺序结构：将各个语句的运行时间求和即可。
- 选择结构(if-else)：
- 循环结构：

#### （5）时间复杂度
时间复杂性分析包含如下步骤：确定问题规模；确定原操作；计算原操作的执行频度；求出渐近时间复杂性。
- 算法的时间复杂度考虑的只是对于问题规模 n 的增长率，则在难以精确计算的情况下，只需考虑它关于 n 的增长率或阶即可。

#### （6）空间复杂度
由于计算机内存容量的不断扩大，空间性能分析的重要性不断降低，常常拿空间换时间，所以空间复杂性可以先过。

## （四）设计模式
## （五）

# 二、scala
# 三、python
