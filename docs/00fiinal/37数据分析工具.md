# 一、Pandas
## 1.Pandas对象
如果从底层视角观察Pandas对象，可以把它们看成增强版的NumPy结构化数组，行列都不再只是简单的整数索引，还可以带上标签。

Pandas的每一个工具、方法和功能几乎都需要我们理解基本数据结构的内部细节。因此，需掌握Pandas的三个基本数据结构：Serises、DataFrame、Index。

### 1.1.Series对象

#### （1）Series是什么
Pandas的Series对象是一个带「索引」数据结构的「一维」数组。

可以用一个数组创建Series对象，如下所示：
```
import pandas as pd
data = pd.Series([0.1, 0.3, 0.5])
data
0    0.1
1    0.3
2    0.5
dtype: float64
```
以上，Series对象将一组数据和一组索引绑定在一起。可以通过values属性和index属性获取一维数组和索引标签。

```
data.values
out:array([0.1, 0.3, 0.5])
data.index
out:RangeIndex(start=0, stop=3, step=1)
```

#### （2）Series与一维NumPy数组比较
Series对象比一维NumPy数组更加通用，灵活。

##### a.Series是通用的NumPy数组
Series对象和一维NumPy数组基本可以等价交换，但两者间的本质差异其实是索引：NumPy数组通过「隐式定义」的「整数索引」获取数值，Series对象用一种「显式定义」的「任意类型索引」与数值关联。

- Series显式定义索引
- Series定义的索引可以是任意类型，如字符串。

**使用字符串定义索引并索引数据**
```
data = pd.Series([0.1, 0.3, 0.5],index=['a','b','c'])
data
out:
a    0.1
b    0.3
c    0.5
dtype: float64
data['b']
out:0.3
```

**使用不连续的整数定义索引并索引数据**
```
data = pd.Series([0.1, 0.3, 0.5],index=[5,20,2])
data
out:
5     0.1
20    0.3
2     0.5
dtype: float64
data[20]
out:0.3
```

##### b.Series是特殊的字典
可以把Pandas的Series对象看成是一种特殊的python字典。字典是一种将任意键映射到一组任意值得数据结构，Series对象其实是一种将类型键映射到一组类型值得数据结构。类型至关重要：就像NumPy数组背后特定类型的经过编译的代码使得它在某些操作上比普通的Python列表更加高效一样，Pandas Series的类型信息使得它在某些操作上比Python的字典更高效。

可以直接用Python的字典创建一个Series对象，让Series对象与字典的额类比更加清晰：
```
population_dict={'北京':2154,'上海':2632,'广州':1531,'深圳':1259}
population = pd.Series(population_dict)
population
out:
北京    2154
上海    2632
广州    1531
深圳    1259
dtype: int64
```

索引获取数据
```
population['北京']
out:
2154
```
切片获取数据
```
population['上海':'深圳']
out:
上海    2632
广州    1531
深圳    1259
dtype: int64
```
#### （3）创建对象
创建Series对象的语法是 `pd.Series(data, index=index)`
- data参数支持多种数据类型，index是一个可选参数。可以通过显式指定索引获取数据
- data可以是列表或NumPy数组，这时index默认值维整数序列
```
pd.Series([1,3,5])
out:
0    1
1    3
2    5
dtype: int64
```
- data可以是一个标量，创建Series对象时会重复填充到每个索引上
```
pd.Series(5, index=[100,200,300])
out:
100    5
200    5
300    5
dtype: int64
```
- data可以是一个字典，index默认是排序的字典键
```
pd.Series({2:'a',1:'b',3:'c'})
out:
2    a
1    b
3    c
dtype: object
```

#### ➤➤➤ Series属性 ➤➤➤
#### （3）Series.values属性

#### （4）Series.index属性

#### （5）获取数据
可以通过显式指定索引获取数据。


### 1.2.DataFrame对象
#### （1）DataFrame是什么
- 如果将Series类比为带灵活索引的一维数组，那么DataFrame就可以看做是一种既有「灵活的行索引」，又有「灵活列名」的二维数组。就像可以把二维数组看成是有序排序的一维数组一样，可以把DataFrame看成是有序排列的若干Series对象。

#### （2）DataFrame与二维NumPy数组比较
##### a.DataFrame是通用的NumPy数组

##### b.DataFrame是特殊的字典

#### ➤➤➤ 创建对象 ➤➤➤
DataFrame对象可以通过许多方式创建。
#### （1）构造函数
`DataFrame(data=None, index=None, columns=None, dtype=None, copy=None)`
- data:ndarray (structured or homogeneous), Iterable, dict, or DataFrame. Dict can contain Series, arrays, constants, dataclass or list-like objects.如果data是一个字典，列顺序遵循插入顺序。
- index
- columns:Index or array-like
- dtype
- copy

#### （2）通过单个Series对象创建
DataFrame是一组Series对象的集合，可以用单个Series创建一个单列的DataFrame。
```
population_dict={'北京':2154,'上海':2632,'广州':1531,'深圳':1259}
population = pd.Series(population_dict)
population
out:
北京    2154
上海    2632
广州    1531
深圳    1259
dtype: int64
pd.DataFrame(population, columns=['population'])
out:
population
北京	2154
上海	2632
广州	1531
深圳	1259
```

#### （3）通过字典列表（list of dicts）创建
任何元素是字典的列表都可以变成DataFrame
```
data = [{'a':i, 'b':2*i} for i in range(3)]
pd.DataFrame(data)
out:
a	b
0	0	0
1	1	2
2	2	4
```
#### （4）通过Series对象字典创建
可以用一个由Series对象构成的字典创建DataFrame
```
population_dict={'北京':2154,'上海':2632,'广州':1531,'深圳':1259}
population = pd.Series(population_dict)
area_dict={'北京':16410,'上海':6340,'广州':7434,'深圳':1997}
area = pd.Series(area_dict)
pd.DataFrame({'population':population,'area':area})
out:
population	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
深圳	1259	1997
```

#### （5）通过NumPy二维数组创建
假如有一个二维数组，就可以创建一个可以指定行列索引值的DataFrame。如果不指定行列索引值，那么行列默认都是整数索引值。
```
pd.DataFrame(np.random.rand(3,2))
out:
    0	1
0	0.783028	0.184407
1	0.726870	0.685593
2	0.757775	0.806291
pd.DataFrame(np.random.rand(3,2),columns=['foo','bar'],index=['a','b','c'])
out:
    foo	bar
a	0.757035	0.684511
b	0.790210	0.807101
c	0.032117	0.170443

```
#### （6）通过NumPy结构化数组创建。

#### ➤➤➤ 数据选择 ➤➤➤
#### （1）将DataFrame当做字典

##### a.字典形式（dictionary-style）

把DataFrame当做一个由若干个Series对象构成的字典。
```
pop = pd.Series({'北京':2154,'上海':2632,'广州':1531,'深圳':1259})
area = pd.Series({'北京':16410,'上海':6340,'广州':7434,'深圳':1997})
data = pd.DataFrame({'pop':pop,'area':area})
data
out:
        pop	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
深圳	1259	1997
```
两个Series分别构成DataFrame的一列，可以通过对列名进行字典形式（dictionary-style）的取值获取数据。
```
data['area']
out:
北京    16410
上海     6340
广州     7434
深圳     1997
Name: area, dtype: int64
```
##### b.属性形式（attribute-style）
可以用属性形式（attribute-style）选择纯字符串列名的数据。
```
data.area
out:
北京    16410
上海     6340
广州     7434
深圳     1997
Name: area, dtype: int64
```
虽然属性形式的数据选择方法很方便，但是它并不是通用的。
- 如果列名不是纯字符串
- 或者列名与DataFrame的方法同名

就不能用属性索引。
```
data.pop
out:
<bound method DataFrame.pop of      pop   area
北京  2154  16410
上海  2632   6340
广州  1531   7434
深圳  1259   1997>
```
为避免歧义，尽量不使用属性形式选择数据。

#### （3）将DataFrame看做二维数组
可以把DataFrame看做是一个增强版的二维数组

##### a.values属性按行查看数组数据
用values属性按行查看数组数据。
```
data.values
out:
array([[ 2154, 16410],
       [ 2632,  6340],
       [ 1531,  7434],
       [ 1259,  1997]], dtype=int64)
```

##### b.对DataFrame进行行列转置
```
data
out:
	    pop	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
深圳	1259	1997
data.T
out:
    北京	上海	广州	深圳
pop	2154	2632	1531	1259
area	16410	6340	7434	1997
```

##### c.用单个行索引获取一行数据
```
data
out:
pop	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
深圳	1259	1997
data.values[0]
out:
array([ 2154, 16410], dtype=int64)
```

##### d.用单个列索引获取一列数据
```
data['area']
out:
北京    16410
上海     6340
广州     7434
深圳     1997
Name: area, dtype: int64
```

##### e.索引器获取数据
接下来，将DataFrame当做数组时，通过loc、iloc、ix索引器，我们就可以像对待NumPy数组一样索引Pandas的底层数组（Python的隐式索引），DataFrame的行列标签会自动保留在结果中。
```
data
out:
  pop	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
深圳	1259	1997
data.iloc[:3,:2]
out:
  pop	area
北京	2154	16410
上海	2632	6340
广州	1531	7434
```

### 1.3.Index对象
## 2.类sql操作
### （1）count计数

### （2）分组计数
```python
from sklearn.datasets import load_boston
import pandas as pd
boston = load_boston()
df=pd.concat([pd.DataFrame(boston.data),pd.DataFrame(boston.target)],axis=1)
df.columns=['CRIM','ZN','INDUS','CHAS','NOX','RM','AGE','DIS','RAD','TAX','PTRATIO','B','LSTAT','MEDV']

df['RAD'].groupby(df.RAD).count()
```

# 二、数据可视化
## 1.前言
### （1）数据可视化
数据可视化是以图示或图形格式表示的数据。让决策者可以看到以直观方式呈现的分析，以便他们可以掌握困难的概念或识别新的模式。

### （2）交互式可视化

## 2.matplotlib
### 2.1.概念
#### （1）matplotlib

## 3.seaborn
### 3.1.前言
#### （1）seaborn
- matplotlib应该是基于python语言最优秀的绘图库了，但是它有一个十分头疼的问题，就是太过于复杂。3000多页的官方文档，上千个方法以及数万个参数，属实是可以用它做任何事，但是又无从下手。seaborn是基于matplotlib核心库进行了更高阶的API封装，可以更轻松的画出漂亮的图形。seaborn的漂亮主要体现在配色更加舒服、以及图形元素的样式更加细腻。

### （2）seaborn特点
- 内置数个经过优化的样式效果
- 单变量和双变量分布绘图更为简单，可用于对数据子集相互比较
- 与NumPy和Pandas数据结构配合良好
- Pandas是一个用于管理关系（表格式）数据集的优秀库，DataFrame时用于数据分析的最广泛使用的数据结构，seaborn在处理DataFrame时非常方便。



